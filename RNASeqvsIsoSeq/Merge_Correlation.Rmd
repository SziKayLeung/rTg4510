---
title: "RNASeqvsIsoSeq of Sample O23"
date: "Report created: `r Sys.Date()`"
author: "Szi Kay Leung"
output:
  rmdformats::readthedown
---

```{r knitr_init, echo=FALSE, cache=FALSE, message=FALSE}
library(knitr)
library(rmdformats)
library(stringr) # Extract strings
library(dplyr)   # dataframe splitting
library(ggpubr) # correlation plot
library(plotly) # interactive graphs
library(ggplot2)
library(grid) # ggplot add corr value
library(gridExtra) # ggplot add corr value
library(ggthemes)
library(DT)
library(tidyr) #gather 

## Global options
options(max.print="75")
opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

**Objective**: To tabulate the number of full-length reads obtained per gene from Isoseq and order genes from high to low, for comparison with RNAseq data for exact sample

**Rationale**: To evaluate whether Isoseq output comparable to RNAseq output

Analysis: 
1. Downloaded raw subread.bam file from Sequel output 
2. CCS and Isoseq3 command line (Lima, Cluster, Polish) 
3. Mapped to mouse genome using GMAP 
4. Tofu Cupcake 
5. Sqanti for isoform characterisation

```{r, echo = TRUE, message = FALSE}
source("/gpfs/mrc0/projects/Research_Project-MRC148213/sl693/Scripts/IsoSeq3_Tg4510/RNASeqvsIsoSeq_2.R")
```

## Step 1) IsoSeq Preparation: Annotate2Abundance
Define function for Importing and Merging SQANTI classification file and TOFU abundance file

**Input**: Sqanti_Filter Classification Output file
  * All details of HQ-unique isoforms classified by assigning PacBio output gene Cluster ID to mouse gene name
  
**Input**: ToFU Abundance Output file
  * Quantification of number of Full_Length per PacBio_ID
  
**Output**: Merged txt file by PacBio ID 
  * Merged txt file has the gene name by which the isoform belongs to (as identified by SQANTI) and the quantification of FL_counts (as quantified in TOFU) by PacBio ID

```{r, echo = TRUE}
sample <- "WT8Merged"
Merged_Data_Input()
```

### Review of SQANTI Classification file
In each SQANTI Classification file, there are parameters that can further allow filtering: 

* Classification of Isoform Types: `r levels(classification_dat$structural_category)`
  + Full Splice Match - matches reference perfectly
  + Incomplete Splice Match - matches reference partially
  + Novel In Catalog - novel isoform using known junctions 
  + Novel Not In Catalog - novel isofroms using novel junctions
  
  + For Sample `r sample`, there are total `r length(classification_dat$isoform)` transcripts, of which there are:  
  **`r length(which(classification_dat$structural_category == "full-splice_match"))`** Full-Splice Match Transcripts, 
  **`r length(which(classification_dat$structural_category == "incomplete-splice_match"))`** Incomplete Splice Match, 
  **`r length(which(classification_dat$structural_category == "novel_in_catalog"))`** Novel In Catalog,
  **`r length(which(classification_dat$structural_category == "novel_not_in_catalog"))`** Novel Not In Catalog
  
* Reverse Transcription Switching: `r levels(classification_dat$RTS_stage <- as.factor(classification_dat$RTS_stage))`
  + TRUE - one of the junctions could be switching artifact; still retained after filtering as overruled if there are canonical junctions 
  + FALSE - not switching artifact 

   + **For sample `r sample`, there are `r length(which(classification_dat$RTS_stage == "FALSE"))` Transcripts labelled as RTS FALSE, and `r length(which(classification_dat$RTS_stage == "TRUE"))` transcripts labelled as RTS TRUE. `r length(which(classification_dat$RTS_stage == "TRUE"))/length(which(classification_dat$RTS_stage == "FALSE")) * 100` of RTS reported. However, note, still `r length(which(classification_dat$RTS_stage == "TRUE" & classification_dat$all_canonical == "non_canonical"))` transcripts with TRUE RTS Stage but non-canonical junction.**

* Coding of transcripts: `r levels(classification_dat$coding)`
  + **For sample `r sample`, there are `r length(which(classification_dat$coding == "coding"))` coding transcripts, and `r length(which(classification_dat$coding == "non_coding"))` transcripts.**
  
* Percentage of As in downstream in TTS: percent of genomic "A"s in the downstream 20 bp window. If this number if high (say > 0.8), the 3' end site of this isoform is probably not reliable 


```{r, echo = TRUE}
head(classification_dat)
Annotate2Abundance_IsoSeq("WTMerged",classification_dat, abundance_dat)
```

## Step 2) IsoSeq Preparation: SumFLCounts
Define function that the FL Counts for all transcripts per gene 

**Motivation**: SQANTI Filter classification outputs one gene with multiple isoforms, thus complicates correlation with RNA-Seq Gene Expression Counts. 
PacBio FL count is presented per isoform rather than per gene. However, FeatureCount's output from RNA-seq data is on a gene level. Therefore FL counts from IsoSeq needs to be summed for more convenient comparison: Total FL Counts of Transcripts per Gene from IsoSeq vs Raw Gene Counts from RNASeq 

Alternative option: select only isoform with the highest number of FL counts, yet biased results especially given if many isoforms with similar or slgihtly smaller number of FL-counts. 
Assumptions: RNA-seq captures expression of all RNA transcripts irrespective of isoforms

```{r, echo = TRUE}
SumFLCounts(Merge_IsoSeq)
```

## Step 3) RNASeq Preparation

**Input**: FeatureCounts of all RNASeq samples (STAR Aligned to mm10 genome, and annotated to Gencode Mouse V20 gtf file) at gene level 
**Output**: FeatureCount of specific sample 

```{r, echo = TRUE}
Input_RNAseq(sample)
```


```{r, echo = TRUE}
Validation_SumFLCounts("App",Merge_IsoSeq)
```

## Step 4) Merge RNASeq and IsoSeq

**Input**: Sample-specific Isoseq (Dataframe: Merge_IsoSeq_SumFL) and RNASeq (Dataframe: RNASeq) Counts
**Output**: Dataframe "Full_Merge": Merged Counts across IsoSeq and RNASeq by gene names

Also to call out specific counts of AD-associated genes, created function AD_Counts. 

```{r, echo = TRUE}
Full_Merge <- merge(Merge_IsoSeq_SumFL,RNASeq,by.x = "associated_gene",by.y = "Mgi_Symbol",all = TRUE)
head(Full_Merge) # output file name = Full_Merge

AD_Genes <- c("Apoe","App","Mapt","Psen1")
AD_Counts(AD_Genes)
```

## Step 5) Data Review for Full_Merge: RNASeq vs IsoSeq

**Motivation**: Within Full_Merge dataframe, interested to know which genes are detected only by IsoSeq, only by RNASeq, and alone. Also later downstream, able to plot the number of respective counts for these genes. 

```{r, echo = TRUE}
Missing_Reads_Review()
```

## Step 6) Correlation of RawData

**output**: Correlation of Gene Expression of IsoSeq FL Counts vs RNASeq Raw Counts. Correlation coefficient calculated from pearson's method (assuming parametric) and considers

```{r, echo = TRUE, warning = FALSE}
cor.test(Full_Merge$Isoseq_FL_Counts,Full_Merge$RNASeq_Raw_Counts, method = "pearson")
Log_Counts()

Run_Corplot(Full_Merge, "Isoseq_FL_Counts", "RNASeq_Raw_Counts")
#Run_Corplot_Interactive(Full_Merge, "Isoseq_FL_Counts", "RNASeq_Raw_Counts")

```

## Step 7) Correlation of log(Data)

**motivation**: As seen above, due to densely populated points of numbers with several extreme values, difficult to see plot. Thus, logged points for visual
**output**: Correlation of Gene Expression of **log(10)**(IsoSeq FL Counts) vs **log(10)**(RNASeq Raw Counts). Note, correlation coefficient doesn't change. However, as it is not possible to log 0, can only consider **genes detected in both technology**.

```{r, echo = TRUE}
Run_Corplot(Log_Full_Merge,"Log_Isoseq_FL_Counts","Log_RNASeq_Raw_Counts")
#Interactive_Log(Log_Full_Merge)
density_plot(Log_Full_Merge,"Log_Isoseq_FL_Counts","Log_RNASeq_Raw_Counts")
#hist(Full_Merge$Isoseq_FL_Counts)
#hist(Full_Merge$RNASeq_Raw_Counts)
```

## Step 8) Missing Reads

**input**: Genes either detected by IsoSeq or RNASeq from Full_Merge dataframe (IsoSeq and RNASeq Counts/gene) 
**output**: Plot of those genes with its respective counts

```{r, echo = TRUE, warning = FALSE}
Missing_Reads_Plot(Full_Merge)
Missing_Genes(5000)
```

### Novel Genes

```{r, echo = TRUE, warning = FALSE}
IsoSeq_Only <- Missing[which(Missing$Detection == "IsoSeq_noRNASeq"),]
IsoSeq_Only <- merge(IsoSeq_Only,classification_dat,by.x = "PacBio_Isoform_ID",by.y = "isoform", all.x = TRUE)
datatable(IsoSeq_Only)
```

## Step 9) Correlation of only FSM transcripts 
```{r, echo=FALSE}
FSM_classification_dat <- classification_dat[which(classification_dat$structural_category == "full-splice_match"),]
Run_FSM(sample,FSM_classification_dat)
density_plot(Log_FSM_Full_Merge,"Log_Isoseq_FL_Counts","Log_RNASeq_Raw_Counts")

Missing_FSM <- FSM_Full_Merge[which(FSM_Full_Merge$Detection == "noIsoSeq_RNASeq" | FSM_Full_Merge$Detection == "IsoSeq_noRNASeq" ),]

```

## Transcript Abundance vs Gencode (All Sqanti Classifications)
### MERGE SQANTI and GENCODE input
Merge the tabulated number of isoforms from SQANTI filter classification txt and GENCODE based on the GeneName 
```{r, echo = TRUE, messages = FALSE}
gencode <- read.table("/gpfs/mrc0/projects/Research_Project-MRC148213/sl693/reference_2019/gencode.vM20_gene_annotation_table.txt", sep="\t")
Prepare_Gencode(gencode)
Sum_Merge4TranscriptAbundance(classification_dat)
```


```{r, echo = FALSE, messages = FALSE}
disease <- read.csv("/gpfs/mrc0/projects/Research_Project-MRC148213/sl693/Scripts/human_mouse_isoseq/Disease_Genes.csv",header = TRUE)
```

### Disease-related genes 
For AD: `r disease[,c("AD")]`
For Autisim: `r disease[,c("Autism")]`

```{r, echo = TRUE, messages = FALSE}

run_disease <- function(dat){
dat_AD <- dat[dat$GeneName %in% disease[,c("AD")],]
dat_Autism <- dat[dat$GeneName %in% disease[,c("Autism")],]
#dat_SZ <- dat[dat$GeneName %in% SZ,]

disease_plot(dat_AD)
}


run_disease(Transcript_Abundance)
gencode[which(gencode$GeneSymbol == "App"),]
classification_dat[which(classification_dat$associated_gene == "App"),c(1:8)]

```


```{r, echo = TRUE, messages = FALSE}

Sum_Merge4TranscriptAbundance(FSM_classification_dat)

```
## Session Info
```{r, echo = FALSE}
sessionInfo()
```

